/* 
   Header section
   Generated by HDLGen, Github https://github.com/abishek-bupathi/HDLGen
   Reference: https://tinyurl.com/VerilogTips 
      
   Component Name : threshold
   Title          : Generate a 32-x32-bit threshold array from 32x32-byte source data array
*/

/*
   Description
   Generate a 32-x32-bit threshold array from 
   - 32x32-byte source data array
   - threshVal(7:0)

   Result bit is asserted if souce byte >= threshVal

   Author(s)      : Fearghal Morgan
   Company        : University of Galway
   Email          : fearghal.morgan@universityofgalway.ie
   Date           : 29/03/2023
*/

/*
   module signal dictionary
   clk  System clock strobe
   rst  Asynchronous reset signal, asserted h 
   ce	threshold component enable. Assertion (h) activates the threshold register components.
   go	Assertion (h) activates threshold finite state machine (FSM)
   reg4x32_CSRA	4 x 32-bit register memory, control and status register A
   reg4x32_CSRB	4 x 32-bit register memory, control and status register B
   BRAM_dOut	256-bit block RAM (BRAM) memory
   active	Asserted to highlight that FSM is active. Signal is a flag and is not used externally. 
   wr	Assertion (h) synchronously writes memory(add) = dataToMem(31:0)
   add	memory address
   datToMem	memory write data
   functBus	96-bit bus which can be connected to any threshold component signals, to be stored / viewed during threshold function execution
*/

/* 
  internal signal dictionary
   NS 	Finite State Machine (FSM) next state and current state
   CS 	Finite State Machine (FSM) next state and current state 
   NSYAdd	Y address std_logic_vector state signals
   CSYAdd	Y address std_logic_vector state signals
   NSXAdd	X address std_logic_vector state signals
   CSXAdd	X address std_logic_vector state signals
   BRAMByte	BRAM_dOut(CSXAdd*8+7 : CSXAdd*8)
   NSThreshVec	thresholdVec std_logic_vector state signals
   CSThreshVec	thresholdVec std_logic_vector state signals
   threshVal	threshVal(7:0) = reg4x32_CSRA(31:24)
*/

// FM No library declarations required //

// module declaration
module threshold(
		ce,
		go,
		reg4x32_CSRA,
		reg4x32_CSRB,
		BRAM_dOut,
		active,
		wr,
		add,
		datToMem,
		functBus,
		clk,
		rst
	);

// <FM> outdent port definitions to left margin
// Port definitions
input  ce;
input  go;
input reg4x32_Array reg4x32_CSRA;
input reg4x32_Array reg4x32_CSRB;
input [255:0] BRAM_dOut;
output  active;
output  wr;
output [7:0] add;
output [31:0] datToMem;
output [95:0] functBus;
input  clk;
input  rst;

reg  active;
reg  wr;
wire [7:0] add;
reg [31:0] datToMem;
reg [95:0] functBus;

// <FM if finite state machine CS/ND type model, include this, assigning binary values to the state names>
parameter idle = 2'b00;
parameter chkBRAM_Byte_GT_thresholdValue = 2'b01;
parameter wr_threshVec_to_reg32x32 = 2'b10;
parameter write_status_to_reg4x32_CSRA0 = 2'b11;

// Internal signal declarations
reg [4:0] NSYAdd;
reg [4:0] CSYAdd;
reg [4:0] NSXAdd;
reg [4:0] CSXAdd;
wire [7:0] BRAMByte;
reg  NS ;
reg  CS ;
reg [31:0] NSThreshVec;
reg [31:0] CSThreshVec;
reg [7:0] threshVal;

// FM No architecture statement required 

// <FM> don't include any reference to component declarations in Verilog
// <FM> No architecture begin statement required 

// NSAndOPDecode always statement
    always @(go or reg4x32_CSRA or reg4x32_CSRB or CSYAdd or CSXAdd or BRAMByte or CS  )
    begin : NSAndOPDecode_p
     // Complete the process if required and delete this comment
    	active <= 1'b0; // default assignment
    	wr <= 1'b0; // default assignment
    	add <= all zeros; // default assignment
    	datToMem <= all zeros; // default assignment
    	functBus <= all zeros; // default assignment
    	NSYAdd <= CSYAdd; // default assignment
    	NSXAdd <= CSXAdd; // default assignment
    	NS  <= CS ; // default assignment
    	case ( CS  )
    		idle :
    			begin

    			end
		 	    // <FM> Include line space before the next case statement 
    		 chkBRAM_Byte_GT_thresholdValue :
    			begin

    			end
		 	    // <FM> Include line space before the next case statement 
    		 wr_threshVec_to_reg32x32 :
    			begin

    			end
		 	    // <FM> Include line space before the next case statement 
    		 write_status_to_reg4x32_CSRA0 :
    			begin

    			end
		 	    // <FM> Include line space before the next case statement 
    		default :
    			begin

    			end
    	endcase
    end

// stateReg always statement
    always @(posedge clk or posedge rst )
    begin : stateReg_p
    // Complete the process if required and delete this comment
    	if ( rst )
    		begin
				CS  <= Idle; //<FM indent from prev line>

				// <FM> Replace 'all zeros' with 0 
				CSYAdd <= all zeros;

				// <FM> Replace 'all zeros' with 0 
				CSXAdd <= all zeros;

				// <FM> Replace 'all zeros' with 0 
				CSthreshVec <= all zeros;
    		end
    	else
    		begin
				CS  <= NS ;
				CSYAdd <= NSYAdd;
				CSXAdd <= NSXAdd;
				CSthreshVec <= NSthreshVec;
    		end
    end

	// <FM> Replace 'all zeros' with 0 
    assign add = all zeros; // Complete the concurrent statement if required

	// <FM> Replace 'all zeros' with 0 
    assign BRAMByte = all zeros; // Complete the concurrent statement if required

endmodule